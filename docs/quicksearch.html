<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"core_ChefWorker.js.html":{"id":"core_ChefWorker.js.html","title":"Source: core/ChefWorker.js","body":" CyberChef Global bake_bakegetDishAs_getDishAs_calculateHighlightsmainsitemap Source: core/ChefWorker.js /** * Web Worker to handle communications between the front-end and the core. * * @author n1474335 [n1474335@gmail.com] * @copyright Crown Copyright 2017 * @license Apache-2.0 */ import Chef from \"./Chef\"; import OperationConfig from \"./config/OperationConfig.json\"; import OpModules from \"./config/modules/OpModules\"; // Add \"&gt;\" to the start of all log messages in the Chef Worker import loglevelMessagePrefix from \"loglevel-message-prefix\"; loglevelMessagePrefix(log, { prefixes: [], staticPrefixes: [\"&gt;\"], prefixFormat: \"%p\" }); // Set up Chef instance self.chef = new Chef(); self.OpModules = OpModules; self.OperationConfig = OperationConfig; // Tell the app that the worker has loaded and is ready to operate self.postMessage({ action: \"workerLoaded\", data: {} }); /** * Respond to message from parent thread. * * Messages should have the following format: * { * action: \"bake\" | \"silentBake\", * data: { * input: {string}, * recipeConfig: {[Object]}, * options: {Object}, * progress: {number}, * step: {boolean} * } | undefined * } */ self.addEventListener(\"message\", function(e) { // Handle message const r = e.data; log.debug(\"ChefWorker receiving command '\" + r.action + \"'\"); switch (r.action) { case \"bake\": bake(r.data); break; case \"silentBake\": silentBake(r.data); break; case \"getDishAs\": getDishAs(r.data); break; case \"docURL\": // Used to set the URL of the current document so that scripts can be // imported into an inline worker. self.docURL = r.data; break; case \"highlight\": calculateHighlights( r.data.recipeConfig, r.data.direction, r.data.pos ); break; case \"setLogLevel\": log.setLevel(r.data, false); break; default: break; } }); /** * Baking handler * * @param {Object} data */ async function bake(data) { // Ensure the relevant modules are loaded self.loadRequiredModules(data.recipeConfig); try { const response = await self.chef.bake( data.input, // The user's input data.recipeConfig, // The configuration of the recipe data.options, // Options set by the user data.progress, // The current position in the recipe data.step // Whether or not to take one step or execute the whole recipe ); self.postMessage({ action: \"bakeComplete\", data: Object.assign(response, { id: data.id }) }); } catch (err) { self.postMessage({ action: \"bakeError\", data: Object.assign(err, { id: data.id }) }); } } /** * Silent baking handler */ function silentBake(data) { const duration = self.chef.silentBake(data.recipeConfig); self.postMessage({ action: \"silentBakeComplete\", data: duration }); } /** * Translates the dish to a given type. */ async function getDishAs(data) { const value = await self.chef.getDishAs(data.dish, data.type); self.postMessage({ action: \"dishReturned\", data: { value: value, id: data.id } }); } /** * Calculates highlight offsets if possible. * * @param {Object[]} recipeConfig * @param {string} direction * @param {Object} pos - The position object for the highlight. * @param {number} pos.start - The start offset. * @param {number} pos.end - The end offset. */ async function calculateHighlights(recipeConfig, direction, pos) { pos = await self.chef.calculateHighlights(recipeConfig, direction, pos); self.postMessage({ action: \"highlightsCalculated\", data: pos }); } /** * Checks that all required modules are loaded and loads them if not. * * @param {Object} recipeConfig */ self.loadRequiredModules = function(recipeConfig) { recipeConfig.forEach(op =&gt; { const module = self.OperationConfig[op.op].module; if (!OpModules.hasOwnProperty(module)) { log.info(`Loading ${module} module`); self.sendStatusMessage(`Loading ${module} module`); self.importScripts(`${self.docURL}/modules/${module}.js`); self.sendStatusMessage(\"\"); } }); }; /** * Send status update to the app. * * @param {string} msg */ self.sendStatusMessage = function(msg) { self.postMessage({ action: \"statusMessage\", data: msg }); }; /** * Send an option value update to the app. * * @param {string} option * @param {*} value */ self.setOption = function(option, value) { self.postMessage({ action: \"optionUpdate\", data: { option: option, value: value } }); }; /** * Send register values back to the app. * * @param {number} opIndex * @param {number} numPrevRegisters * @param {string[]} registers */ self.setRegisters = function(opIndex, numPrevRegisters, registers) { self.postMessage({ action: \"setRegisters\", data: { opIndex: opIndex, numPrevRegisters: numPrevRegisters, registers: registers } }); }; × Search results Close "},"web_index.js.html":{"id":"web_index.js.html","title":"Source: web/index.js","body":" CyberChef Global bake_bakegetDishAs_getDishAs_calculateHighlightsmainsitemap Source: web/index.js /** * @author n1474335 [n1474335@gmail.com] * @copyright Crown Copyright 2016 * @license Apache-2.0 */ // Styles import \"./stylesheets/index.js\"; // Libs import \"arrive\"; import \"snackbarjs\"; import \"bootstrap-material-design\"; import \"bootstrap-colorpicker\"; import moment from \"moment-timezone\"; import * as CanvasComponents from \"../core/lib/CanvasComponents\"; // CyberChef import App from \"./App\"; import Categories from \"../core/config/Categories.json\"; import OperationConfig from \"../core/config/OperationConfig.json\"; /** * Main function used to build the CyberChef web app. */ function main() { const defaultFavourites = [ \"To Base64\", \"From Base64\", \"To Hex\", \"From Hex\", \"To Hexdump\", \"From Hexdump\", \"URL Decode\", \"Regular expression\", \"Entropy\", \"Fork\", \"Magic\" ]; const defaultOptions = { updateUrl: true, showHighlighter: true, treatAsUtf8: true, wordWrap: true, showErrors: true, errorTimeout: 4000, attemptHighlight: true, theme: \"classic\", useMetaKey: false, ioDisplayThreshold: 512, logLevel: \"info\", autoMagic: true, }; document.removeEventListener(\"DOMContentLoaded\", main, false); window.app = new App(Categories, OperationConfig, defaultFavourites, defaultOptions); window.app.setup(); } window.compileTime = moment.tz(COMPILE_TIME, \"DD/MM/YYYY HH:mm:ss z\", \"UTC\").valueOf(); window.compileMessage = COMPILE_MSG; // Make libs available to operation outputs window.CanvasComponents = CanvasComponents; document.addEventListener(\"DOMContentLoaded\", main, false); × Search results Close "},"web_LoaderWorker.js.html":{"id":"web_LoaderWorker.js.html","title":"Source: web/LoaderWorker.js","body":" CyberChef Global bake_bakegetDishAs_getDishAs_calculateHighlightsmainsitemap Source: web/LoaderWorker.js /** * Web Worker to load large amounts of data without locking up the UI. * * @author n1474335 [n1474335@gmail.com] * @copyright Crown Copyright 2017 * @license Apache-2.0 */ /** * Respond to message from parent thread. */ self.addEventListener(\"message\", function(e) { const r = e.data; if (r.hasOwnProperty(\"file\")) { self.loadFile(r.file); } }); /** * Loads a file object into an ArrayBuffer, then transfers it back to the parent thread. * * @param {File} file */ self.loadFile = function(file) { const reader = new FileReader(); const data = new Uint8Array(file.size); let offset = 0; const CHUNK_SIZE = 10485760; // 10MiB const seek = function() { if (offset &gt;= file.size) { self.postMessage({\"progress\": 100}); self.postMessage({\"fileBuffer\": data.buffer}, [data.buffer]); return; } self.postMessage({\"progress\": Math.round(offset / file.size * 100)}); const slice = file.slice(offset, offset + CHUNK_SIZE); reader.readAsArrayBuffer(slice); }; reader.onload = function(e) { data.set(new Uint8Array(reader.result), offset); offset += CHUNK_SIZE; seek(); }; reader.onerror = function(e) { self.postMessage({\"error\": reader.error.message}); }; seek(); }; × Search results Close "},"web_static_sitemap.js.html":{"id":"web_static_sitemap.js.html","title":"Source: web/static/sitemap.js","body":" CyberChef Global bake_bakegetDishAs_getDishAs_calculateHighlightsmainsitemap Source: web/static/sitemap.js import sm from \"sitemap\"; import OperationConfig from \"../../core/config/OperationConfig.json\"; /** * Generates an XML sitemap for all CyberChef operations and a number of recipes. * * @author n1474335 [n1474335@gmail.com] * @copyright Crown Copyright 2018 * @license Apache-2.0 */ const sitemap = sm.createSitemap({ hostname: \"https://gchq.github.io/CyberChef\", }); sitemap.add({ url: \"/\", changefreq: \"weekly\", priority: 1.0 }); for (const op in OperationConfig) { sitemap.add({ url: `/?op=${encodeURIComponent(op)}`, changeFreq: \"yearly\", priority: 0.5 }); } const xml = sitemap.toString(); console.log(xml); // eslint-disable-line no-console × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" CyberChef Global bake_bakegetDishAs_getDishAs_calculateHighlightsmainsitemap Global Members sitemap Generates an XML sitemap for all CyberChef operations and a number of recipes. Author: &lt;p&gt;n1474335 [n1474335@gmail.com]&lt;/p&gt; Copyright: Crown Copyright 2018 License: Apache-2.0 Source: web/static/sitemap.js, line 5 Methods bake(data) Baking handler Parameters: Name Type Description data Object Source: core/ChefWorker.js, line 86 _bake() Silent baking handler Source: core/ChefWorker.js, line 121 getDishAs() Translates the dish to a given type. Source: core/ChefWorker.js, line 134 _getDishAs(recipeConfig, direction, pos) Calculates highlight offsets if possible. Parameters: Name Type Description recipeConfig Array.&lt;Object&gt; direction string pos Object The position object for the highlight. Properties Name Type Description start number The start offset. end number The end offset. Source: core/ChefWorker.js, line 150 _calculateHighlights(recipeConfig) Checks that all required modules are loaded and loads them if not. Parameters: Name Type Description recipeConfig Object Source: core/ChefWorker.js, line 169 main() Main function used to build the CyberChef web app. Source: web/index.js, line 24 × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" CyberChef Global bake_bakegetDishAs_getDishAs_calculateHighlightsmainsitemap CyberChef The Cyber Swiss Army Knife CyberChef is a simple, intuitive web app for carrying out all manner of \"cyber\" operations within a web browser. These operations include simple encoding like XOR or Base64, more complex encryption like AES, DES and Blowfish, creating binary and hexdumps, compression and decompression of data, calculating hashes and checksums, IPv6 and X.509 parsing, changing character encodings, and much more. The tool is designed to enable both technical and non-technical analysts to manipulate data in complex ways without having to deal with complex tools or algorithms. It was conceived, designed, built and incrementally improved by an analyst in their 10% innovation time over several years. Live demo CyberChef is still under active development. As a result, it shouldn't be considered a finished product. There is still testing and bug fixing to do, new features to be added and additional documentation to write. Please contribute! Cryptographic operations in CyberChef should not be relied upon to provide security in any situation. No guarantee is offered for their correctness. A live demo can be found here - have fun! How it works There are four main areas in CyberChef: The input box in the top right, where you can paste, type or drag the text or file you want to operate on. The output box in the bottom right, where the outcome of your processing will be displayed. The operations list on the far left, where you can find all the operations that CyberChef is capable of in categorised lists, or by searching. The recipe area in the middle, where you can drag the operations that you want to use and specify arguments and options. You can use as many operations as you like in simple or complex ways. Some examples are as follows: Decode a Base64-encoded string Convert a date and time to a different time zone Parse a Teredo IPv6 address Convert data from a hexdump, then decompress Decrypt and disassemble shellcode Display multiple timestamps as full dates Carry out different operations on data of different types Use parts of the input as arguments to operations Perform AES decryption, extracting the IV from the beginning of the cipher stream Automagically detect several layers of nested encoding Features Drag and drop Operations can be dragged in and out of the recipe list, or reorganised. Files up to 500MB can be dragged over the input box to load them directly into the browser. Auto Bake Whenever you modify the input or the recipe, CyberChef will automatically \"bake\" for you and produce the output immediately. This can be turned off and operated manually if it is affecting performance (if the input is very large, for instance). Automated encoding detection CyberChef uses a number of techniques to attempt to automatically detect which encodings your data is under. If it finds a suitable operation which can make sense of your data, it displays the 'magic' icon in the Output field which you can click to decode your data. Breakpoints You can set breakpoints on any operation in your recipe to pause execution before running it. You can also step through the recipe one operation at a time to see what the data looks like at each stage. Save and load recipes If you come up with an awesome recipe that you know you’ll want to use again, just click \"Save recipe\" and add it to your local storage. It'll be waiting for you next time you visit CyberChef. You can also copy the URL, which includes your recipe and input, to easily share it with others. Search If you know the name of the operation you want or a word associated with it, start typing it into the search field and any matching operations will immediately be shown. Highlighting When you highlight text in the input or output, the offset and length values will be displayed and, if possible, the corresponding data will be highlighted in the output or input respectively (example: highlight the word 'question' in the input to see where it appears in the output). Save to file and load from file You can save the output to a file at any time or load a file by dragging and dropping it into the input field. Files up to around 500MB are supported (depending on your browser), however some operations may take a very long time to run over this much data. CyberChef is entirely client-side It should be noted that none of your recipe configuration or input (either text or files) is ever sent to the CyberChef web server - all processing is carried out within your browser, on your own computer. Due to this feature, CyberChef can be compiled into a single HTML file. You can download this file and drop it into a virtual machine, share it with other people, or use it independently on your local machine. Browser support CyberChef is built to support Google Chrome 40+ Mozilla Firefox 35+ Microsoft Edge 14+ Contributing Contributing a new operation to CyberChef is super easy! There is a quickstart script which will walk you through the process. If you can write basic JavaScript, you can write a CyberChef operation. An installation walkthrough, how-to guides for adding new operations and themes, descriptions of the repository structure, available data types and coding conventions can all be found in the project wiki pages. Push your changes to your fork. Submit a pull request. If you are doing this for the first time, you will be prompted to sign the GCHQ Contributor Licence Agreement via the CLA assistant on the pull request. This will also ask whether you are happy for GCHQ to contact you about a token of thanks for your contribution, or about job opportunities at GCHQ. Licencing CyberChef is released under the Apache 2.0 Licence and is covered by Crown Copyright. × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
